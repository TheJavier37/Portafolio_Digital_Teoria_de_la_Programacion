‚û°Ô∏è [Regresar al Portafolio Principal](index.md)


# üìÇ Unidad 2 ‚Äì Contenidos y Tareas  

---

## üìò Contenidos de la Unidad  

[üîπEstructuras condicionales](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#-estructuras-condicionales-tipos-y-ejercicios-en-diagrama-de-flujo-y-en-c)  
&nbsp;&nbsp;&nbsp;&nbsp;[üé´ if](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#-if)  
&nbsp;&nbsp;&nbsp;&nbsp;[üé´ if-else](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#-if-else)  
&nbsp;&nbsp;&nbsp;&nbsp;[üé´ switch case](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#-switch-case)   
[üîπEstructuras repetitivas](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#-estructuras-repetitivas-tipos-y-ejercicios-en-diagrama-de-flujo-y-en-c)  
&nbsp;&nbsp;&nbsp;&nbsp;[üéüÔ∏è while](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#%EF%B8%8F-while)  
&nbsp;&nbsp;&nbsp;&nbsp;[üéüÔ∏è do...while](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#%EF%B8%8F-dowhile)  
&nbsp;&nbsp;&nbsp;&nbsp;[üéüÔ∏è for](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#%EF%B8%8F-for)  
[üîπEjercicio combinando](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#-ejercicio-combinando-estructura-condicional-y-repetitiva-java-o-python)
&nbsp;&nbsp;&nbsp;&nbsp;[üî∏Descripci√≥n del problema](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#descripci%C3%B3n-del-problema)  
&nbsp;&nbsp;&nbsp;&nbsp;[üî∏Diagrama de flujo simplificado](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#diagrama-de-flujo-simplificado)  
&nbsp;&nbsp;&nbsp;&nbsp;[üî∏Programa](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#programa)  
&nbsp;&nbsp;&nbsp;&nbsp;[üî∏Verificaci√≥n](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#verificaci%C3%B3n)  
[üîπPrincipales dificultades en la aplicaci√≥n de los contenidos](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#-principales-dificultades-en-la-aplicaci%C3%B3n-de-los-contenidos)  
[üîπReflexi√≥n cr√≠tica de los aprendizajes de la unidad](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#-reflexi%C3%B3n-cr%C3%ADtica-de-los-aprendizajes-de-la-unidad)  
[üì¶ Tareas Entregadas](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#-tareas-entregadas)  
[üè† Aprendizaje Aut√≥nomo](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#aprendizaje-aut%C3%B3nomo-aa)  
[ü™¥ Aprendizaje Practico Experimental](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#aprendizaje-practico-experimental-ape)   
 
---

## üìë Tabla de ilustraciones  
---

|   Figura   | Descripci√≥n / Ilustraci√≥n |
|------------|---------------------------|
| [Fig 1](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#fig-1-diagrama-de-flujo-del-condicional-if-simple)  | Diagrama de flujo del condicional if simple                          |
| [Fig 2](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#fig-2-diagrama-de-flujo-del-condicional-if-else)  | Diagrama de flujo del condicional if-else                          |
| [Fig 3](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#fig-3-diagrama-de-flujo-del-condicional-switch-case)  | Diagrama de flujo del condicional switch case                          |
| [Fig 4](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#fig-4-diagrama-de-flujo-del-bucle-while)  | Diagrama de flujo del bucle while                          |
| [Fig 5](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#fig-5-diagrama-de-flujo-del-bucle-dowhile)  | Diagrama de flujo del bucle do...while                          |
| [Fig 6](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#fig-6-diagrama-de-flujo-del-bucle-for)  | Diagrama de flujo del bucle for                          |
| [Fig 7](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#fig-7-diagrama-de-flujo-del-ejercicion-planteado-en-python)  | Diagrama de Flujo del ejercicio planteado en Python                          |
| [Fig 8](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#fig-8-caso-de-prueba-en-el-que-se-ingresa-un-numero-entero-positivo)  | Caso de Prueba en el que se ingresa un numero entero positivo                          |
| [Fig 9](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#fig-9-caso-de-prueba-en-el-que-se-ingresa-un-numero-negativo)  | Caso de Prueba en el que se ingresa un numero negativo                          |
| [Fig 10](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#fig-10-caso-de-prueba-en-el-que-se-inserta-un-dato-tipo-char) | Fig 10: Caso de Prueba en el que se inserta un dato tipo char                          |
| [Fig 11](https://github.com/TheJavier37/Portafolio_Digital_Teoria_de_la_Programacion/blob/main/unidad2.md#fig-11-caso-de-prueba-en-el-que-se-inserta-un-dato-tipo-float) | Fig 11: Caso de Prueba en el que se inserta un dato tipo float                          |


- ## üîπ **Estructuras condicionales (tipos y ejercicios en diagrama de flujo y en C)**

- ### üé´ if
La sentencia if simple permite ejecutar un bloque de instrucciones solo cuando una condici√≥n l√≥gica se cumple. Si la condici√≥n es falsa, el programa contin√∫a su ejecuci√≥n sin realizar ninguna acci√≥n adicional asociada al if.
```
if (condicion) {
    // instrucciones si la condici√≥n es verdadera
}
```
#### Fig 1: Diagrama de flujo del condicional if simple
<p align="center">
<img width="393" height="245" alt="image" src="https://github.com/user-attachments/assets/aa4128a9-45c8-4015-92c1-601365cff253" />
</p>

#### Fig 1.1: Diagrama de flujo del ejercicio pr√°ctico
<p align="center">
<img width="540" height="475" alt="image" src="https://github.com/user-attachments/assets/5b942be9-b887-4f34-9ceb-c85fd502c3cb" />
</p>

#### Ejercicio: Detectar cual n√∫mero de los dos numeros ingresados por el usuario es el mayor numero
```
#include <stdio.h>

int main(){

    float numero1, numero2;

    printf("Ingrese el primer numero\n");
    scanf("%f", &numero1);
    printf("Ingrese el segundo numero\n");
    scanf("%f", &numero2);
    getchar();
    
    if(numero1 > numero2){
        printf("El primer numero %.2f es mayor que %.2f", numero1, numero2);
    }

    if(numero1 < numero2){
        printf("El primer numero %.2f es menor que %.2f", numero1, numero2);
    }

    if(numero1 == numero2){
        printf("Los numeros %.2f y %.2f son iguales", numero1, numero2);
    }

    return 0;

}
```
---

- ### üé´ if-else
La estructura IF‚ÄìELSE permite ejecutar una acci√≥n cuando la condici√≥n es verdadera y una acci√≥n alternativa cuando es falsa. Si la condici√≥n se cumple, se ejecuta el bloque del IF; en caso contrario, se ejecuta el bloque del ELSE.

```
if (condicion) {
    // instrucciones si la condici√≥n es verdadera
} else {
    // instrucciones si la condici√≥n es falsa
}
```
#### Fig 2: Diagrama de flujo del condicional if-else
<p align="center">
<img width="358" height="204" alt="image" src="https://github.com/user-attachments/assets/c135ea9c-97c4-4cf9-b284-8edba893e321" />
</p>

#### Fig 2.1: Diagrama de flujo del ejercicio pr√°ctico
<p align="center">
<img width="800" height="300" alt="image" src="https://github.com/user-attachments/assets/f3f39ff6-3794-4aac-b639-74a43804872d" />
</p>

#### Ejercicio: Verificar si el numero ingresado por el usuario es m√∫ltiplo de 3
```
#include <stdio.h>

int main(){

    int numero;

    printf("Ingrese un numero\n");
    scanf("%i", &numero);
    getchar();
    
    if(numero % 3 == 0 ){
        printf("El numero %i es multiplo de tres", numero);
    }else{
        printf("El numero %i no es multiplo de tres", numero);
    }

    return 0;

}
```
---

- ### üé´ switch case
La estructura condicional switch permite evaluar el valor de una variable y ejecutar diferentes bloques de instrucciones seg√∫n el caso que coincida con ese valor. Cada caso representa una posible opci√≥n, y si ninguno coincide, puede definirse un bloque default que se ejecuta como alternativa por defecto.

```
switch (variable) {
    case valor1:
        // instrucciones para valor1
        break;

    case valor2:
        // instrucciones para valor2
        break;

    case valor3:
        // instrucciones para valor3
        break;

    default:
        // instrucciones si no coincide ning√∫n caso
        break;
}
```
#### Fig 3: Diagrama de flujo del condicional switch case
<p align="center">
<img width="487" height="158" alt="image" src="https://github.com/user-attachments/assets/6fd0fcc4-694a-46cd-afed-bc47cee14b63" />
</p>

#### Fig 3.1: Diagrama de flujo del ejercicio pr√°ctico
<p align="center">
<img width="1760" height="461" alt="image" src="https://github.com/user-attachments/assets/3385227c-dcbc-4c4d-8aa0-a5d0fc329237" />
</p>

#### Ejercicio: Mostrar el dia de la semana segun el numero ingresado por usuario del 1 al 7
```
#include <stdio.h>

int main(){

    int dia;
    printf("Ingrese el dia de la semana en numero del 1 al 7\n");
    scanf("%i", &dia);
    getchar();

    switch(dia){

        case 1:
            printf("Es lunes\n");
            break;

        case 2:
            printf("Es martes\n");
            break;
        
        case 3:
            printf("Es miercoles\n");
            break;

        case 4:
            printf("Es jueves\n");
            break;
        
        case 5:
            printf("Es viernes\n");
            break;

        case 6:
            printf("Es sabado\n");
            break;

        case 7:
            printf("Es domingo\n");
            break;

        default: 
            printf("Por favor ingrese un numero valido");
            break;
    }

    return 0;
}
```

---

- ## üîπ **Estructuras repetitivas (tipos y ejercicios en diagrama de flujo y en C)**

- ### üéüÔ∏è while
Bucle controlado por condici√≥n evaluada antes de ejecutar el cuerpo. √ötil cuando no se sabe cu√°ntas veces se repetir√° y la ejecuci√≥n depende de una condici√≥n que puede cambiar dentro del bucle. Puede no ejecutarse ninguna vez si la condici√≥n es falsa desde el inicio.
```
while (condicion) {
    // instrucciones mientras la condici√≥n sea verdadera
}
```
#### Fig 4: Diagrama de flujo del bucle while
<p align="center">
<img width="232" height="204" alt="image" src="https://github.com/user-attachments/assets/20534b01-eb1b-4ca7-85cc-3d03f3512893" />
</p>

#### Fig 4.1: Diagrama de flujo del ejercico pr√°ctico
<p align="center">
<img width="350" height="475" alt="image" src="https://github.com/user-attachments/assets/d0ced023-9dd8-49fc-84a4-30af6ac8bdc8" />
</p>

#### Ejercicio: Sumar 10 n√∫meros sucesivamente ingresados por el usuario
```
#include <stdio.h>

int main(){

    int valor = 0;
    int suma = 0;
    int orden = 1;

    while (orden <= 10){
        printf("Ingrese un valor a sumar\n");
        scanf("%i", &valor);

        suma = suma + valor;
        orden = orden + 1;
    }

    printf("El valor sumado es %i", suma);

    return 0;
}
```
---

- ### üéüÔ∏è do...while
Similar a como funciona el bucle while, pero la condici√≥n se eval√∫a despu√©s del cuerpo: garantiza que el cuerpo se ejecute al menos una vez. √ötil para men√∫s o lectura/validaci√≥n donde quieres ejecutar la acci√≥n antes de comprobar la condici√≥n
```
do {
    // instrucciones que se ejecutan al menos una vez
} while (condicion);
```
#### Fig 5: Diagrama de flujo del bucle do...while
<p align="center">
<img width="232" height="204" alt="image" src="https://github.com/user-attachments/assets/4cc28ca5-0c6b-4d5d-9bd2-435fb5537107" />
</p>

#### Fig 5.1: Diagrama de flujo del ejercicio pr√°ctico
<p align="center">
<img width="560" height="475" alt="image" src="https://github.com/user-attachments/assets/46f7b4b9-8013-40b8-8792-addca0def9d6" />

</p>

#### Ejercicio: Encontrar el denominador v√°lido del numero ingresado por el usuario
```
#include <stdio.h>

int main(){

    float numerador, denominador;
    float coeficiente;

    printf("Ingrese el numerador\n");
    scanf("%f", &numerador);

    do{
        printf("Ingrese un denominador valido\n");
        scanf("%f", &denominador);

    }while (denominador == 0 );

    coeficiente = numerador / denominador;

    printf("Su coeficiente es igual a %.2f", coeficiente);

    return 0;
}
```
---

- ### üéüÔ∏è for
Bucle que se inicializa una variable que act√∫a como contador, luego se verifica una condici√≥n que decide si el ciclo contin√∫a o se detiene, y al final de cada repetici√≥n se actualiza el contador. Este proceso se repite autom√°ticamente mientras la condici√≥n sea verdadera, lo que permite ejecutar tareas de forma ordenada y controlada cuando ya sabemos cu√°ntas veces deben repetirse.
```
for (inicializacion; condicion; incremento) {
    // instrucciones durante cada iteraci√≥n
}
```
#### Fig 6: Diagrama de flujo del bucle for
<p align="center">
<img width="284" height="298" alt="image" src="https://github.com/user-attachments/assets/042de146-751e-4683-9be9-9728f0f103ec" />
</p>

#### Fig 6.1: Diagrama de flujo del ejercico pr√°ctico
<p align="center">
<img width="690" height="475" alt="image" src="https://github.com/user-attachments/assets/7a47fcbf-4802-4e63-8f39-162993f133c4" />
</p>


#### Ejercicio: Calcular el factorial del n√∫mero ingresado por el usuario
```
#include <stdio.h>

int main(){

    long long int factorial, resultado = 1, i;

    printf("Ingrese un numero para convertilo a factorial\n");
    scanf("%llx", &factorial);

    for(i = 1; i <= factorial; i++){
        resultado = resultado * i;
    }

    printf("El factorial de su numero ingresado %llx es igual a: %llx", factorial, resultado);

    return 0;
}
```
---

- ## üîπ **Ejercicio combinando estructura condicional y repetitiva (en Python).**

---

- ### üî∏Descripci√≥n del problema  
üìùEl programa solicita al usuario ingresar un n√∫mero entero positivo y, a partir de dicho valor, determina todos los n√∫meros primos comprendidos desde el 2 hasta el n√∫mero ingresado.  
üìùPara lograrlo, se emplean dos funciones: una encargada de verificar si un n√∫mero es primo evaluando sus posibles divisores, y otra que construye la lista de n√∫meros primos dentro del rango definido.  
üìùEl programa incorpora validaciones que impiden el ingreso de valores negativos, iguales a 0 o 1, as√≠ como entradas no num√©ricas, garantizando que la ejecuci√≥n contin√∫e √∫nicamente con un dato correcto.  
üìùFinalmente, el programa muestra en pantalla la lista de todos los n√∫meros primos encontrados entre 2 y el valor l√≠mite proporcionado por el usuario.  

---

- ### üî∏Diagrama de flujo simplificado
#### Fig 7: Diagrama de Flujo del ejercicio planteado en Python
<p align="center">
<img width="1308" height="2168" alt="DIAGRAMARECTI" src="https://github.com/user-attachments/assets/8e4096b8-df7c-43a1-ba5f-5c24c35db242" />
</p>
---

- ### üî∏Programa
```
n = 0

while n <= 1:
    print("Ingrese un n√∫mero mayor que 1: ")
    entrada = input()

    es_numero = True

    # Verificar caracter por caracter
    for c in entrada:
        if c < '0' or c > '9':
            es_numero = False
            break

    if es_numero:
        n = int(entrada)
        if n <= 1:
            print("Error: el n√∫mero debe ser mayor que 1.\n")
    else:
        print("Error: debe ingresar un n√∫mero v√°lido.\n")
        n = 0

# Lista para guardar los primos
primos = []

# Proceso para identificar primos
for num in range(2, n + 1):

    primo = True

    for i in range(2, num):
        if num % i == 0:
            primo = False
            break

    if primo:
        primos.append(num)

print("N√∫meros primos encontrados:", primos)
```
---

- ### üî∏Verificaci√≥n
#### Fig 8: Caso de Prueba en el que se ingresa un numero entero positivo
<p align="center">
<img width="673" height="50" alt="image" src="https://github.com/user-attachments/assets/63d19e6b-ff7a-4a7c-8b84-fc5abfa7cd19" />

#### Fig 9: Caso de Prueba en el que se ingresa un numero negativo
<p align="center">
<img width="413" height="53" alt="image" src="https://github.com/user-attachments/assets/efc8e654-b517-4972-92c2-1b67204f1cdb" />
</p>

#### Fig 10: Caso de Prueba en el que se inserta un dato tipo char
<p align="center">
<img width="422" height="48" alt="image" src="https://github.com/user-attachments/assets/e80efc4a-1f51-45c1-920f-0fc9e98c314c" />
</p>

#### Fig 11: Caso de Prueba en el que se inserta un dato tipo float
<p align="center">
<img width="420" height="45" alt="image" src="https://github.com/user-attachments/assets/e033527c-461c-4ca8-a235-e44b22b6d565" />
</p>

---

## üîπ **Principales dificultades en la aplicaci√≥n de los contenidos**  

üëÅÔ∏è Uno de los mayores retos fue unificar todos los conceptos en un ejercicio completo: funciones que verifican primos, ciclos que generan listas, validaciones y manejo de errores. Coordinar el flujo l√≥gico general sin perder claridad requiri√≥ pr√°ctica y revisi√≥n del funcionamiento de cada parte.

---

## üîπ **Reflexi√≥n cr√≠tica de los aprendizajes de la unidad**  

üìñ El trabajo con las estructuras condicionales y repetitivas en C permiti√≥ consolidar una comprensi√≥n s√≥lida sobre c√≥mo controlar el flujo de un programa de manera eficiente y ordenada. Implementar if, if-else, switch, while, do‚Ä¶while y for fortaleci√≥ la capacidad de seleccionar la estructura adecuada para cada situaci√≥n, logrando algoritmos m√°s claros, predecibles y bien organizados. La combinaci√≥n entre diagramas de flujo y c√≥digo en C facilit√≥ visualizar la l√≥gica antes de escribirla, haciendo que la transici√≥n del dise√±o a la implementaci√≥n sea cada vez m√°s natural.

üß† Adem√°s, el desarrollo del ejercicio integrador reforz√≥ la habilidad de dividir un problema en partes m√°s peque√±as, reutilizar funcionalidades mediante funciones y aplicar validaciones para guiar al usuario hacia una ejecuci√≥n correcta. Este proceso permiti√≥ comprender c√≥mo las estructuras del lenguaje C se conectan para formar programas completos, coherentes y eficientes. En conjunto, la unidad fortaleci√≥ la confianza para resolver problemas mediante programaci√≥n estructurada, demostrando que el dominio progresivo de C abre la puerta a soluciones m√°s profesionales y rigurosas.

---

## üì¶ Tareas Entregadas  

---

### üè†Aprendizaje Aut√≥nomo (AA)  

- ‚úÖ [**AA1: Diferencias entre tipos de estructuras condicionales**](https://drive.google.com/file/d/1hR10PXmLpH3mXsA7WaJdDxKocgz4XCft/view?usp=sharing)  
- ‚úÖ [**AA2: Estructuras algor√≠tmicas de control**](https://drive.google.com/file/d/1VRzeayROfxj-JrlATHLxD7n6hMBdvhmX/view?usp=sharing)  

---

### ü™¥Aprendizaje Practico Experimental (APE)  
- ‚úÖ [**APE1: Aplicaci√≥n de estructuras condicionales en la resoluci√≥n de problemas.**](https://drive.google.com/file/d/1Rz85MmNwuCmvIG2LT5qjja1AGYhlRgCe/view?usp=sharing)  
- ‚úÖ [**APE2: Aplicaci√≥n de estructuras repetitivas en la resoluci√≥n de problemas.**](https://drive.google.com/file/d/1vtIfIIOYT4YPw6Ep0WKzO7BH3j1FeoY2/view?usp=sharing)  


